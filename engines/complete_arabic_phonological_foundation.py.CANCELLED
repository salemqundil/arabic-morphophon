#!/usr/bin/env python3
# -*- coding: utf-8 -*-
""""
Complete Arabic Phonological Foundation System (Zero Layer Core)
================================================================
Enterprise-Grade Atomic Phoneme and Diacritic Classification,
    Professional Python Implementation with Zero-Tolerance Error Handling,
    This module provides the foundational layer for Arabic linguistic processing:
- Complete atomic function classification (1-5 functions per unit)
- Professional phoneme and diacritic registry with full Arabic coverage
- Enterprise-grade resolver system with position tracking
- Zero-tolerance UTF-8 handling and linguistic accuracy
- Complete compatibility with existing Arabic NLP engine ecosystem,
    Author: Arabic NLP Expert Team - GitHub Copilot,
    Version: 2.0.0 - COMPLETE IMPLEMENTATION,
    Date: 2025-07-24,
    License: MIT,
    Encoding: UTF 8
""""

import logging
    import sys
    from typing import List, Dict, Optional, Any
    from dataclasses import dataclass
    from enum import Enum

# Configure professional logging,
    logging.basicConfig()
    logging.basicConfig(level=logging.INFO,)
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s','
    handlers=[
        logging.FileHandler()
            'complete_arabic_phonological_foundation.log', encoding='utf 8''
        ),
        logging.StreamHandler(sys.stdout),
    ])

logger = logging.getLogger(__name__)


# ═══════════════════════════════════════════════════════════════════════════════════
# ATOMIC FUNCTION CLASSIFICATION SYSTEM
# ═══════════════════════════════════════════════════════════════════════════════════


class PhonemeFunction(Enum):
    """Atomic functional classification for Arabic phonemes (1 5 functions per phoneme)""""

    # Root Functions (الوظائف الجذرية)
    ROOT_FIRST = "جذر_أول""
    ROOT_SECOND = "جذر_ثاني""
    ROOT_THIRD = "جذر_ثالث""
    ROOT_WEAK = "جذر_ضعيف""
    ROOT_FOURTH = "جذر_رابع""

    # Morphological Functions (الوظائف الصرفية)
    PRONOUN_SUFFIX = "ضمير_لاحقة""
    FEMININE_MARKER = "علامة_تأنيث""
    PLURAL_MARKER = "علامة_جمع""
    DERIVATIONAL_AFFIX = "زائدة_اشتقاقية""
    PASSIVE_MARKER = "علامة_مبني_للمجهول""

    # Syntactic Functions (الوظائف النحوية)
    PREPOSITION = "أداة_جر""
    CONJUNCTION = "أداة_عطف""
    NEGATION_MARKER = "أداة_نفي""
    DEFINITE_ARTICLE = "أل_التعريف""

    # Phonological Functions (الوظائف الصوتية)
    EMPHATIC_CONSONANT = "حرف_مطبّق""
    GLIDE_CONSONANT = "حرف_انزلاقي""
    NASAL_CONSONANT = "حرف_أنفي""
    LONG_VOWEL = "حرف_مد""


class DiacriticFunction(Enum):
    """Atomic functional classification for Arabic diacritics (1 5 functions per diacritic)""""

    # Temporal Functions (الوظائف الزمنية)
    PAST_TENSE = "دلالة_زمن_الماضي""
    PRESENT_TENSE = "دلالة_زمن_المضارع""
    IMPERATIVE_MOOD = "صيغة_الأمر""
    JUSSIVE_MOOD = "صيغة_جزم""

    # Case Functions (وظائف الإعراب)
    NOMINATIVE_CASE = "علامة_رفع""
    ACCUSATIVE_CASE = "علامة_نصب""
    GENITIVE_CASE = "علامة_جر""

    # Definiteness Functions (وظائف التعريف والتنكير)
    INDEFINITENESS = "تنكير""
    DEFINITENESS = "تعريف""

    # Morphological Functions (الوظائف الصرفية)
    GEMINATION = "تضعيف""
    PASSIVE_VOICE = "صيغة_المبني_للمجهول""
    FEMININE_PLURAL = "جمع_مؤنث""
    VERBAL_NOUN = "مصدر""

    # Prosodic Functions (الوظائف العروضية)
    EMPHASIS = "توكيد""
    LENGTHENING = "إطالة""
    SHORTENING = "قصر""
    ELISION = "حذف""
    PREPOSITION_MARKER = "علامة_حرف_جر""


# ═══════════════════════════════════════════════════════════════════════════════════
# PHONEME AND DIACRITIC REGISTRY SYSTEM
# ═══════════════════════════════════════════════════════════════════════════════════


@dataclass,
    class PhonemeEntry:
    """Professional phoneme registry entry with atomic functions""""

    symbol: str,
    name: str,
    features: List[str]
    functions: List[PhonemeFunction]
    phoneme_type: str = "consonant""
    ipa_symbol: str = """
    frequency: float = 0.0


@dataclass,
    class DiacriticEntry:
    """Professional diacritic registry entry with atomic functions""""

    symbol: str,
    name: str,
    phonetic_type: str,
    functions: List[DiacriticFunction]
    ipa_symbol: str = """
    syllable_weight: float = 1.0


# ═══════════════════════════════════════════════════════════════════════════════════
# COMPLETE ARABIC PHONEME REGISTRY (28 LETTERS)
# ═══════════════════════════════════════════════════════════════════════════════════


def create_complete_phoneme_registry() -> List[PhonemeEntry]:
    """Create comprehensive registry of all 28 Arabic letters with atomic functions""""

    return [
        # ا (alif) - Long vowel and weak root,
    PhonemeEntry()
            "ا","
            "ألف","
            ["long_vowel", "central", "low"],"
            [PhonemeFunction.ROOT_WEAK, PhonemeFunction.LONG_VOWEL],
            "long_vowel","
            "aː","
            0.134),
        # ب (ba) - Bilabial stop with multiple functions,
    PhonemeEntry()
            "ب","
            "باء","
            ["bilabial", "stop", "voiced"],"
            [PhonemeFunction.ROOT_FIRST, PhonemeFunction.PREPOSITION],
            "consonant","
            "b","
            0.089),
        # ت (ta) - Dental stop with morphological functions,
    PhonemeEntry()
            "ت","
            "تاء","
            ["dental", "stop", "voiceless"],"
            [
                PhonemeFunction.ROOT_THIRD,
                PhonemeFunction.PRONOUN_SUFFIX,
                PhonemeFunction.FEMININE_MARKER,
                PhonemeFunction.DERIVATIONAL_AFFIX,
            ],
            "consonant","
            "t","
            0.156),
        # ث (tha) - Dental fricative,
    PhonemeEntry()
            "ث","
            "ثاء","
            ["dental", "fricative", "voiceless"],"
            [PhonemeFunction.ROOT_FIRST],
            "consonant","
            "θ","
            0.012),
        # ج (jim) - Postalveolar affricate,
    PhonemeEntry()
            "ج","
            "جيم","
            ["postalveolar", "affricate", "voiced"],"
            [PhonemeFunction.ROOT_SECOND],
            "consonant","
            "dʒ","
            0.056),
        # ح (ha) - Pharyngeal fricative,
    PhonemeEntry()
            "ح","
            "حاء","
            ["pharyngeal", "fricative", "voiceless"],"
            [PhonemeFunction.ROOT_FIRST],
            "consonant","
            "ħ","
            0.078),
        # خ (kha) - Uvular fricative with emphasis,
    PhonemeEntry()
            "خ","
            "خاء","
            ["uvular", "fricative", "voiceless"],"
            [PhonemeFunction.ROOT_SECOND, PhonemeFunction.EMPHATIC_CONSONANT],
            "consonant","
            "x","
            0.034),
        # د (dal) - Dental stop,
    PhonemeEntry()
            "د","
            "دال","
            ["dental", "stop", "voiced"],"
            [PhonemeFunction.ROOT_THIRD],
            "consonant","
            "d","
            0.067),
        # ذ (dhal) - Dental fricative,
    PhonemeEntry()
            "ذ","
            "ذال","
            ["dental", "fricative", "voiced"],"
            [PhonemeFunction.ROOT_SECOND],
            "consonant","
            "ð","
            0.023),
        # ر (ra) - Alveolar trill with multiple functions,
    PhonemeEntry()
            "ر","
            "راء","
            ["alveolar", "trill", "voiced"],"
            [
                PhonemeFunction.ROOT_SECOND,
                PhonemeFunction.PREPOSITION,
                PhonemeFunction.DERIVATIONAL_AFFIX,
            ],
            "consonant","
            "r","
            0.089),
        # ز (zay) - Alveolar fricative,
    PhonemeEntry()
            "ز","
            "زاي","
            ["alveolar", "fricative", "voiced"],"
            [PhonemeFunction.ROOT_THIRD],
            "consonant","
            "z","
            0.034),
        # س (sin) - Alveolar fricative with plural function,
    PhonemeEntry()
            "س","
            "سين","
            ["alveolar", "fricative", "voiceless"],"
            [PhonemeFunction.ROOT_FIRST, PhonemeFunction.PLURAL_MARKER],
            "consonant","
            "s","
            0.078),
        # ش (shin) - Postalveolar fricative,
    PhonemeEntry()
            "ش","
            "شين","
            ["postalveolar", "fricative", "voiceless"],"
            [PhonemeFunction.ROOT_SECOND],
            "consonant","
            "ʃ","
            0.045),
        # ص (sad) - Emphatic alveolar fricative,
    PhonemeEntry()
            "ص","
            "صاد","
            ["alveolar", "fricative", "voiceless", "pharyngealized"],"
            [PhonemeFunction.ROOT_SECOND, PhonemeFunction.EMPHATIC_CONSONANT],
            "consonant","
            "sˤ","
            0.034),
        # ض (dad) - Emphatic alveolar stop,
    PhonemeEntry()
            "ض","
            "ضاد","
            ["alveolar", "stop", "voiced", "pharyngealized"],"
            [PhonemeFunction.ROOT_THIRD, PhonemeFunction.EMPHATIC_CONSONANT],
            "consonant","
            "dˤ","
            0.023),
        # ط (ta) - Emphatic alveolar stop,
    PhonemeEntry()
            "ط","
            "طاء","
            ["alveolar", "stop", "voiceless", "pharyngealized"],"
            [PhonemeFunction.ROOT_FIRST, PhonemeFunction.EMPHATIC_CONSONANT],
            "consonant","
            "tˤ","
            0.034),
        # ظ (za) - Emphatic dental fricative,
    PhonemeEntry()
            "ظ","
            "ظاء","
            ["dental", "fricative", "voiced", "pharyngealized"],"
            [PhonemeFunction.ROOT_FOURTH, PhonemeFunction.EMPHATIC_CONSONANT],
            "consonant","
            "ðˤ","
            0.012),
        # ع (ain) - Pharyngeal fricative,
    PhonemeEntry()
            "ع","
            "عين","
            ["pharyngeal", "fricative", "voiced"],"
            [PhonemeFunction.ROOT_FIRST],
            "consonant","
            "ʕ","
            0.089),
        # غ (ghain) - Uvular fricative with emphasis,
    PhonemeEntry()
            "غ","
            "غين","
            ["uvular", "fricative", "voiced"],"
            [PhonemeFunction.ROOT_SECOND, PhonemeFunction.EMPHATIC_CONSONANT],
            "consonant","
            "ɣ","
            0.034),
        # ف (fa) - Labiodental fricative,
    PhonemeEntry()
            "ف","
            "فاء","
            ["labiodental", "fricative", "voiceless"],"
            [PhonemeFunction.ROOT_FIRST],
            "consonant","
            "f","
            0.067),
        # ق (qaf) - Uvular stop with emphasis,
    PhonemeEntry()
            "ق","
            "قاف","
            ["uvular", "stop", "voiceless"],"
            [PhonemeFunction.ROOT_SECOND, PhonemeFunction.EMPHATIC_CONSONANT],
            "consonant","
            "q","
            0.045),
        # ك (kaf) - Velar stop with preposition function,
    PhonemeEntry()
            "ك","
            "كاف","
            ["velar", "stop", "voiceless"],"
            [PhonemeFunction.ROOT_THIRD, PhonemeFunction.PREPOSITION],
            "consonant","
            "k","
            0.089),
        # ل (lam) - Alveolar lateral with multiple functions,
    PhonemeEntry()
            "ل","
            "لام","
            ["alveolar", "lateral", "voiced"],"
            [
                PhonemeFunction.ROOT_SECOND,
                PhonemeFunction.DEFINITE_ARTICLE,
                PhonemeFunction.CONJUNCTION,
            ],
            "consonant","
            "l","
            0.156),
        # م (mim) - Bilabial nasal with multiple functions,
    PhonemeEntry()
            "م","
            "ميم","
            ["bilabial", "nasal", "voiced"],"
            [
                PhonemeFunction.ROOT_FIRST,
                PhonemeFunction.PRONOUN_SUFFIX,
                PhonemeFunction.NASAL_CONSONANT,
            ],
            "consonant","
            "m","
            0.134),
        # ن (nun) - Alveolar nasal with multiple functions,
    PhonemeEntry()
            "ن","
            "نون","
            ["alveolar", "nasal", "voiced"],"
            [
                PhonemeFunction.ROOT_THIRD,
                PhonemeFunction.PRONOUN_SUFFIX,
                PhonemeFunction.PLURAL_MARKER,
                PhonemeFunction.NEGATION_MARKER,
                PhonemeFunction.NASAL_CONSONANT,
            ],
            "consonant","
            "n","
            0.156),
        # ه (ha) - Glottal fricative with multiple functions,
    PhonemeEntry()
            "ه","
            "هاء","
            ["glottal", "fricative", "voiceless"],"
            [
                PhonemeFunction.ROOT_THIRD,
                PhonemeFunction.PRONOUN_SUFFIX,
                PhonemeFunction.FEMININE_MARKER,
            ],
            "consonant","
            "h","
            0.089),
        # و (waw) - Labio velar approximant with multiple functions,
    PhonemeEntry()
            "و","
            "واو","
            ["labio_velar", "approximant", "voiced"],"
            [
                PhonemeFunction.ROOT_WEAK,
                PhonemeFunction.PRONOUN_SUFFIX,
                PhonemeFunction.CONJUNCTION,
                PhonemeFunction.LONG_VOWEL,
            ],
            "long_vowel","
            "w","
            0.134),
        # ي (ya) - Palatal approximant with multiple functions,
    PhonemeEntry()
            "ي","
            "ياء","
            ["palatal", "approximant", "voiced"],"
            [
                PhonemeFunction.ROOT_WEAK,
                PhonemeFunction.PRONOUN_SUFFIX,
                PhonemeFunction.DERIVATIONAL_AFFIX,
                PhonemeFunction.LONG_VOWEL,
            ],
            "long_vowel","
            "j","
            0.134),
    ]


# ═══════════════════════════════════════════════════════════════════════════════════
# COMPLETE ARABIC DIACRITIC REGISTRY (10 DIACRITICS)
# ═══════════════════════════════════════════════════════════════════════════════════


def create_complete_diacritic_registry() -> List[DiacriticEntry]:
    """Create comprehensive registry of all Arabic diacritics with atomic functions""""

    return [
        # فتحة (fatha) - Short vowel with multiple functions,
    DiacriticEntry()
            "َ","
            "فتحة","
            "short_vowel","
            [
                DiacriticFunction.PAST_TENSE,
                DiacriticFunction.ACCUSATIVE_CASE,
                DiacriticFunction.FEMININE_PLURAL,
            ],
            "a","
            1.0),
        # ضمة (damma) - Short vowel with multiple functions,
    DiacriticEntry()
            "ُ","
            "ضمة","
            "short_vowel","
            [
                DiacriticFunction.PRESENT_TENSE,
                DiacriticFunction.NOMINATIVE_CASE,
                DiacriticFunction.PASSIVE_VOICE,
            ],
            "u","
            1.0),
        # كسرة (kasra) - Short vowel with multiple functions,
    DiacriticEntry()
            "ِ","
            "كسرة","
            "short_vowel","
            [
                DiacriticFunction.GENITIVE_CASE,
                DiacriticFunction.PREPOSITION_MARKER,
                DiacriticFunction.FEMININE_PLURAL,
            ],
            "i","
            1.0),
        # سكون (sukun) - Zero vowel with multiple functions,
    DiacriticEntry()
            "ْ","
            "سكون","
            "sukun","
            [
                DiacriticFunction.JUSSIVE_MOOD,
                DiacriticFunction.SHORTENING,
                DiacriticFunction.ELISION,
            ],
            "","
            0.0),
        # شدة (shadda) - Gemination with multiple functions,
    DiacriticEntry()
            "ّ","
            "شدة","
            "shadda","
            [
                DiacriticFunction.GEMINATION,
                DiacriticFunction.EMPHASIS,
                DiacriticFunction.VERBAL_NOUN,
            ],
            "ː","
            2.0),
        # تنوين فتح (tanwin fath) - Indefinite accusative,
    DiacriticEntry()
            "ً","
            "تنوين فتح","
            "tanwin","
            [DiacriticFunction.ACCUSATIVE_CASE, DiacriticFunction.INDEFINITENESS],
            "an","
            1.5),
        # تنوين ضم (tanwin damm) - Indefinite nominative,
    DiacriticEntry()
            "ٌ","
            "تنوين ضم","
            "tanwin","
            [DiacriticFunction.NOMINATIVE_CASE, DiacriticFunction.INDEFINITENESS],
            "un","
            1.5),
        # تنوين كسر (tanwin kasr) - Indefinite genitive,
    DiacriticEntry()
            "ٍ","
            "تنوين كسر","
            "tanwin","
            [DiacriticFunction.GENITIVE_CASE, DiacriticFunction.INDEFINITENESS],
            "in","
            1.5),
        # مدة (maddah) - Lengthening marker,
    DiacriticEntry("ٓ", "مدة", "maddah", [DiacriticFunction.LENGTHENING], "aː", 2.0),"
        # ألف خنجرية (dagger alif) - Short lengthening,
    DiacriticEntry()
            "ٰ", "ألف خنجرية", "dagger_alif", [DiacriticFunction.SHORTENING], "a", 0.5"
        ),
    ]


# ═══════════════════════════════════════════════════════════════════════════════════
# PHONOLOGICAL UNIT RESOLVER SYSTEM
# ═══════════════════════════════════════════════════════════════════════════════════


@dataclass,
    class ResolvedPhoneme:
    """Resolved phoneme with complete analysis""""

    symbol: str,
    name: str,
    position: int,
    features: List[str]
    functions: List[str]
    phoneme_type: str,
    ipa_symbol: str,
    frequency: float,
    context_role: Optional[str] = None


@dataclass,
    class ResolvedDiacritic:
    """Resolved diacritic with complete analysis""""

    symbol: str,
    name: str,
    position: int,
    phonetic_type: str,
    functions: List[str]
    ipa_symbol: str,
    syllable_weight: float,
    attached_to: Optional[str] = None


@dataclass,
    class PhonologicalAnalysis:
    """Complete phonological analysis result""""

    input_word: str,
    phonemes: List[ResolvedPhoneme]
    diacritics: List[ResolvedDiacritic]
    total_phonemes: int,
    total_diacritics: int,
    analysis_confidence: float,
    linguistic_features: Dict[str, Any]


# ═══════════════════════════════════════════════════════════════════════════════════
# MAIN PHONOLOGICAL FUNCTION RESOLVER CLASS
# ═══════════════════════════════════════════════════════════════════════════════════


class CompletePhonologicalFunctionResolver:
    """Enterprise grade phonological function resolver with complete analysis""""

    def __init__(self):
        """Initialize the complete phonological resolver""""
        self.logger = logging.getLogger('CompletePhonologicalResolver')'

        # Create registries,
    self.phoneme_registry = create_complete_phoneme_registry()
        self.diacritic_registry = create_complete_diacritic_registry()

        # Create lookup maps,
    self.phoneme_map: Dict[str, PhonemeEntry] = {
            p.symbol: p for p in self.phoneme_registry
        }
        self.diacritic_map: Dict[str, DiacriticEntry] = {
            d.symbol: d for d in self.diacritic_registry
        }

        # Create feature sets,
    self.diacritic_set = set(self.diacritic_map.keys())
        self.phoneme_set = set(self.phoneme_map.keys())

        self.logger.info()
            f"✅ CompletePhonologicalResolver initialized with {len(self.phoneme_registry)} phonemes and {len(self.diacritic_registry) diacritics}""
        )

    def resolve_complete(self, word: str) -> PhonologicalAnalysis:
        """Perform complete phonological analysis with enterprise grade processing""""

        self.logger.info(f"🔬 Starting complete analysis of: {word}")"

        phonemes = []
        diacritics = []
        position = 0,
    for i, char in enumerate(word):
            # Process phonemes,
    if char in self.phoneme_map:
                p = self.phoneme_map[char]
                position += 1,
    resolved_phoneme = ResolvedPhoneme()
                    symbol=char,
                    name=p.name,
                    position=position,
                    features=p.features.copy(),
                    functions=[f.value for f in p.functions],
                    phoneme_type=p.phoneme_type,
                    ipa_symbol=p.ipa_symbol,
                    frequency=p.frequency)
                phonemes.append(resolved_phoneme)

            # Process diacritics,
    elif char in self.diacritic_map:
                d = self.diacritic_map[char]
                attached_to = ()
                    word[i - 1] if i > 0 and word[i - 1] in self.phoneme_set else None
                )

                resolved_diacritic = ResolvedDiacritic()
                    symbol=char,
                    name=d.name,
                    position=i,
                    phonetic_type=d.phonetic_type,
                    functions=[f.value for f in d.functions],
                    ipa_symbol=d.ipa_symbol,
                    syllable_weight=d.syllable_weight,
                    attached_to=attached_to)
                diacritics.append(resolved_diacritic)

        # Calculate linguistic features,
    linguistic_features = self._extract_linguistic_features(phonemes, diacritics)

        # Calculate analysis confidence,
    confidence = self._calculate_confidence(phonemes, diacritics, word)

        analysis = PhonologicalAnalysis()
            input_word=word,
            phonemes=phonemes,
            diacritics=diacritics,
            total_phonemes=len(phonemes),
            total_diacritics=len(diacritics),
            analysis_confidence=confidence,
            linguistic_features=linguistic_features)

        self.logger.info()
            f"✅ Analysis complete: {len(phonemes)} phonemes, {len(diacritics)} diacritics, {confidence:.1f}% confidence""
        )

        return analysis,
    def _extract_linguistic_features()
        self, phonemes: List[ResolvedPhoneme], diacritics: List[ResolvedDiacritic]
    ) -> Dict[str, Any]:
        """Extract comprehensive linguistic features from analysis""""

        features = {
            'phoneme_types': {},'
            'diacritic_types': {},'
            'functions': {},'
            'phonetic_features': {},'
            'prosodic_weight': 0.0,'
            'emphatic_consonants': [],'
            'weak_consonants': [],'
            'root_consonants': [],'
            'grammatical_markers': [],'
        }

        # Analyze phonemes,
    for phoneme in phonemes:
            # Count phoneme types,
    features['phoneme_types'][phoneme.phoneme_type] = ()'
                features['phoneme_types'].get(phoneme.phoneme_type, 0) + 1'
            )

            # Count functions,
    for func in phoneme.functions:
                features['functions'][func] = features['functions'].get(func, 0) + 1'

            # Extract phonetic features,
    for feature in phoneme.features:
                if feature not in features['phonetic_features']:'
                    features['phonetic_features'][feature] = []'
                features['phonetic_features'][feature].append(phoneme.symbol)'

            # Identify special consonant types,
    if 'pharyngealized' in phoneme.features or 'emphatic' in phoneme.features:'
                features['emphatic_consonants'].append(phoneme.symbol)'

            if phoneme.phoneme_type == 'long_vowel':'
                features['weak_consonants'].append(phoneme.symbol)'

            if any('جذر' in func for func in phoneme.functions):'
                features['root_consonants'].append(phoneme.symbol)'

        # Analyze diacritics,
    for diacritic in diacritics:
            # Count diacritic types,
    features['diacritic_types'][diacritic.phonetic_type] = ()'
                features['diacritic_types'].get(diacritic.phonetic_type, 0) + 1'
            )

            # Add to prosodic weight,
    features['prosodic_weight'] += diacritic.syllable_weight'

            # Count functions,
    for func in diacritic.functions:
                features['functions'][func] = features['functions'].get(func, 0) + 1'

            # Identify grammatical markers,
    if any()
                marker in func,
    for func in diacritic.functions,
    for marker in ['علامة', 'دلالة', 'صيغة']'
            ):
                features['grammatical_markers'].append(diacritic.symbol)'

        return features,
    def _calculate_confidence()
        self,
        phonemes: List[ResolvedPhoneme],
        diacritics: List[ResolvedDiacritic],
        word: str) -> float:
        """Calculate analysis confidence based on coverage and accuracy""""

        total_chars = len(word)
        processed_chars = len(phonemes) + len(diacritics)

        # Base confidence on coverage,
    coverage_confidence = ()
            (processed_chars / total_chars) * 100 if total_chars > 0 else 0
        )

        # Boost confidence for high-frequency phonemes,
    frequency_boost = sum(p.frequency for p in phonemes) * 10

        # Final confidence (capped at 100%)
        final_confidence = min(coverage_confidence + frequency_boost, 100.0)

        return final_confidence,
    def describe_complete(self, word: str) -> None:
        """Display comprehensive analysis results with professional formatting""""

        analysis = self.resolve_complete(word)

        print("\n" + "=" * 80)"
        print(f"🔠 تحليل شامل للكلمة: {word}")"
        print("=" * 80)"

        print("\n📊 ملخص التحليل:")"
        print(f"   • إجمالي الفونيمات: {analysis.total_phonemes}")"
        print(f"   • إجمالي الحركات: {analysis.total_diacritics}")"
        print(f"   • مستوى الثقة: {analysis.analysis_confidence:.1f%}")"
        print()
            f"   • الوزن العروضي: {analysis.linguistic_features['prosodic_weight']:.1f}"'"
        )

        print("\n🧩 الفونيمات:")"
        for p in analysis.phonemes:
            funcs = ", ".join(p.functions)"
            print()
                f"  • {p.symbol} ({p.name}) | الموضع: {p.position} | النوع: {p.phoneme_type}""
            )
            print(f"    السمات: {', '.join(p.features)}")'"
            print(f"    الوظائف: {funcs}")"
            print(f"    IPA: {p.ipa_symbol} | التكرار: {p.frequency:.3f}")"

        print("\n🎵 الحركات:")"
        for d in analysis.diacritics:
            funcs = ", ".join(d.functions)"
            attached = f"متصل بـ: {d.attached_to}" if d.attached_to else "مستقل""
            print(f"  • {d.symbol} ({d.name}) | الموضع: {d.position} | {attached}}")"
            print(f"    النوع: {d.phonetic_type} | الوزن: {d.syllable_weight}")"
            print(f"    الوظائف: {funcs}")"
            print(f"    IPA: {d.ipa_symbol}")"

        print("\n🏗️ الخصائص اللغوية:")"
        features = analysis.linguistic_features,
    if features['emphatic_consonants']:'
            print(f"   • الحروف المفخمة: {', '.join(features['emphatic_consonants'])}")'"

        if features['weak_consonants']:'
            print(f"   • حروف العلة: {', '.join(features['weak_consonants'])}")'"

        if features['root_consonants']:'
            print(f"   • الحروف الجذرية: {', '.join(features['root_consonants'])}")'"

        if features['grammatical_markers']:'
            print()
                f"   • العلامات النحوية: {', '.join(features['grammatical_markers'])}"'"
            )

        print("\n" + "=" * 80)"
        print(f"✅ تحليل مكتمل للكلمة: {word}")"
        print("=" * 80)"


# ═══════════════════════════════════════════════════════════════════════════════════
# COMPREHENSIVE TESTING FRAMEWORK
# ═══════════════════════════════════════════════════════════════════════════════════


def run_comprehensive_tests():
    """Run comprehensive tests covering all phonemes and diacritics""""

    print("=" * 80)"
    print("نظام التحليل الصوتي الذري للغة العربية - الطبقة الصفرية المكتملة")"
    print("Complete Arabic Atomic Phonological Analysis System - Zero Layer")"
    print("=" * 80)"
    print(f"Python Version: {sys.version}")"
    print("Encoding: UTF 8")"
    print("Environment: WinSurf IDE Professional")"

    resolver = CompletePhonologicalFunctionResolver()

    print("\n📊 إحصائيات النظام:")"
    print(f"   • عدد الفونيمات المسجلة: {len(resolver.phoneme_registry)}")"
    print(f"   • عدد الحركات المسجلة: {len(resolver.diacritic_registry)}")"

    # Test cases covering all phonological phenomena,
    test_words = [
        "كَتَبَ",  # Past tense verb"
        "يَكْتُبُ",  # Present tense verb"
        "مُدَرِّسٌ",  # Participle with shadda"
        "كِتَابٌ",  # Noun with long vowel"
        "قَرَأْتُ",  # Past with pronoun"
        "الْبَيْتُ",  # Definite article"
        "فَعَّلَ",  # Intensive verb form"
        "مَسْؤُولٌ",  # Word with hamza"
        "اسْتَخْدَمَ",  # Form X verb"
        "مُسْتَشْفَى",  # Hospital (complex morphology)"
        "الطَّالِبَةُ",  # Definite feminine student"
        "وَالْمُدَرِّسُونَ",  # Conjunction with plural"
    ]

    print(f"\n🧪 اختبارات شاملة لـ {len(test_words)} كلمة:")"
    print(" " * 80)"

    for i, word in enumerate(test_words, 1):
        print(f"\n[{i:2d}/12] تحليل الكلمة: {word}")"
        print(" " * 40)"
        resolver.describe_complete(word)
        print(" " * 80)"

    print("\n🎉 انتهاء الاختبارات الشاملة بنجاح!")"
    print("Complete testing successfully finished!")"
    print("=" * 80)"


# ═══════════════════════════════════════════════════════════════════════════════════
# MAIN EXECUTION
# ═══════════════════════════════════════════════════════════════════════════════════


if __name__ == "__main__":"
    try:
        run_comprehensive_tests()
    except Exception as e:
        logger.error(f"❌ Critical error in Arabic Phonological Foundation: {e}")"
        sys.exit(1)

