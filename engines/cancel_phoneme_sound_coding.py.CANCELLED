#!/usr/bin/env python3
"""
🚫 PHONEME/SOUND CODING CANCELLATION TOOL
=========================================

Safety-first approach to cancel all sound-related coding:
- Identifies all phoneme/phonological/sound files
- Moves them to quarantine (preserves original files)
- Creates minimal stub files to prevent import errors
- Generates comprehensive cancellation report
- Preserves Arabic content but removes risky sound processing

Strategy: PRESERVE → QUARANTINE → STUB → REPORT
"""

import os
import shutil
import re
from pathlib import Path
from datetime import datetime


class PhonemeCodeCanceller:
    def __init__(self):
        self.quarantine_dir = Path("quarantine_phoneme_sound_code")
        self.quarantine_dir.mkdir(exist_ok=True)

        self.cancelled_files = []
        self.stub_files_created = []
        self.preserved_files = []
        self.risky_patterns_found = []

        # Patterns to identify sound/phoneme-related files
        self.phoneme_patterns = [
            "phoneme",
            "phonolog",
            "sound",
            "audio",
            "speech",
            "acoustic",
            "pronunciation",
            "phonetic",
            "syllable",
        ]

        # File extensions to check
        self.target_extensions = [".py", ".html", ".yaml", ".json", ".md", ".log"]

        print("🚫 PHONEME/SOUND CODING CANCELLATION")
        print("=" * 50)

    def is_phoneme_related(self, file_path):
        """Check if file is phoneme/sound-related"""
        file_str = str(file_path).lower()

        # Check filename and path for phoneme-related patterns
        for pattern in self.phoneme_patterns:
            if pattern in file_str:
                return True

        return False

    def scan_for_risky_patterns(self, file_path):
        """Scan file content for risky sound-processing patterns"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            risky_patterns = [
                r'\.wav',
                r'\.mp3',
                r'\.ogg',
                r'audio',
                r'frequency',
                r'hertz',
                r'amplitude',
                r'waveform',
                r'acoustic',
                r'speech_',
                r'phonetic',
                r'pronunciation',
                r'syllable_sound',
            ]

            found_risks = []
            for pattern in risky_patterns:
                matches = re.findall(pattern, content, re.IGNORECASE)
                if matches:
                    found_risks.append(f"{pattern}: {len(matches)} occurrences")

            return found_risks

        except Exception as e:
            return [f"Error scanning: {e}"]

    def create_stub_file(self, original_path):
        """Create a minimal stub file to prevent import errors"""
        try:
            # Only create stubs for Python files that might be imported
            if not str(original_path).endswith('.py'):
                return False

            stub_content = f'''"""
STUB FILE - PHONEME/SOUND CODING CANCELLED
==========================================

Original file: {original_path.name}
Cancelled on: {datetime.now().isoformat()}
Reason: Sound/phoneme processing cancelled for safety

This stub prevents import errors.
Original file moved to: quarantine_phoneme_sound_code/
"""

# Minimal stub to prevent import errors
def __getattr__(name):
    """Stub function to handle any attribute access"""
    print(f"⚠️ Phoneme/sound functionality '{{name}}' has been cancelled")
    return lambda *args, **kwargs: None

# Common classes that might be imported
class AudioEngine:
    def __init__(self, *args, **kwargs):
        print("⚠️ AudioEngine has been cancelled")

    def __getattr__(self, name):
        return lambda *args, **kwargs: None

class PhonemeEngine:
    def __init__(self, *args, **kwargs):
        print("⚠️ PhonemeEngine has been cancelled")

    def __getattr__(self, name):
        return lambda *args, **kwargs: None

class PhonologicalEngine:
    def __init__(self, *args, **kwargs):
        print("⚠️ PhonologicalEngine has been cancelled")

    def __getattr__(self, name):
        return lambda *args, **kwargs: None

# Prevent any sound processing
PHONEME_PROCESSING_CANCELLED = True
'''

            with open(original_path, 'w', encoding='utf-8') as f:
                f.write(stub_content)

            self.stub_files_created.append(str(original_path))
            return True

        except Exception as e:
            print(f"❌ Failed to create stub for {original_path}: {e}")
            return False

    def quarantine_file(self, file_path):
        """Move file to quarantine directory"""
        try:
            # Create subdirectory structure in quarantine
            relative_path = file_path.relative_to(Path.cwd())
            quarantine_path = self.quarantine_dir / relative_path

            # Create parent directories
            quarantine_path.parent.mkdir(parents=True, exist_ok=True)

            # Move file to quarantine
            shutil.move(str(file_path), str(quarantine_path))

            self.cancelled_files.append(
                {
                    'original': str(file_path),
                    'quarantine': str(quarantine_path),
                    'size': (
                        quarantine_path.stat().st_size
                        if quarantine_path.exists()
                        else 0
                    ),
                }
            )

            return quarantine_path

        except Exception as e:
            print(f"❌ Failed to quarantine {file_path}: {e}")
            return None

    def scan_workspace(self):
        """Scan entire workspace for phoneme/sound-related files"""
        print("🔍 Scanning workspace for phoneme/sound files...")

        phoneme_files = []

        # Walk through all files
        for root, dirs, files in os.walk('.'):
            # Skip backup and quarantine directories
            if 'backup' in root.lower() or 'quarantine' in root.lower():
                continue

            for file in files:
                file_path = Path(root) / file

                # Check file extension
                if file_path.suffix.lower() in self.target_extensions:
                    # Check if phoneme-related
                    if self.is_phoneme_related(file_path):
                        # Scan for risky patterns
                        risks = self.scan_for_risky_patterns(file_path)

                        phoneme_files.append(
                            {
                                'path': file_path,
                                'risks': risks,
                                'size': file_path.stat().st_size,
                            }
                        )

        return phoneme_files

    def cancel_phoneme_files(self, phoneme_files):
        """Cancel all identified phoneme files"""
        print(f"\n🚫 Cancelling {len(phoneme_files)} phoneme/sound files...")

        for file_info in phoneme_files:
            file_path = file_info['path']
            risks = file_info['risks']

            print(f"\n📁 Processing: {file_path}")

            if risks:
                print(
                    f"   ⚠️ Risks found: {', '.join(risks[:3])}{'...' if len(risks) > 3 else ''}"
                )
                self.risky_patterns_found.extend(risks)

            # Move to quarantine
            quarantine_path = self.quarantine_file(file_path)

            if quarantine_path:
                print(f"   ✅ Moved to quarantine: {quarantine_path}")

                # Create stub if it's a Python file
                if file_path.suffix.lower() == '.py':
                    if self.create_stub_file(file_path):
                        print(f"   📝 Created stub file: {file_path}")
                    else:
                        print(f"   ⚠️ Could not create stub for: {file_path}")
            else:
                print(f"   ❌ Failed to quarantine: {file_path}")

    def generate_report(self):
        """Generate comprehensive cancellation report"""
        report_file = (
            f"phoneme_cancellation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        )

        report_content = f"""# 🚫 PHONEME/SOUND CODING CANCELLATION REPORT

**Date:** {datetime.now().isoformat()}
**Operation:** Complete cancellation of sound/phoneme processing code

## 📊 SUMMARY

- **Files Cancelled:** {len(self.cancelled_files)}
- **Stub Files Created:** {len(self.stub_files_created)}
- **Risky Patterns Found:** {len(self.risky_patterns_found)}
- **Total Data Quarantined:** {sum(f['size'] for f in self.cancelled_files):,} bytes

## 📁 CANCELLED FILES

"""

        for file_info in self.cancelled_files:
            report_content += f"- `{file_info['original']}` → `{file_info['quarantine']}` ({file_info['size']:,} bytes)\n"

        if self.stub_files_created:
            report_content += f"\n## 📝 STUB FILES CREATED\n\n"
            for stub in self.stub_files_created:
                report_content += f"- `{stub}` (prevents import errors)\n"

        if self.risky_patterns_found:
            report_content += f"\n## ⚠️ RISKY PATTERNS DETECTED\n\n"
            risk_counts = {}
            for risk in self.risky_patterns_found:
                risk_counts[risk] = risk_counts.get(risk, 0) + 1

            for risk, count in risk_counts.items():
                report_content += f"- `{risk}` (found {count} times)\n"

        report_content += f"""
## 🔒 QUARANTINE LOCATION

All cancelled files have been moved to:
```
{self.quarantine_dir.absolute()}
```

## 🛡️ SAFETY MEASURES

1. ✅ Original files preserved in quarantine
2. ✅ Stub files created to prevent import errors
3. ✅ No Arabic language content destroyed
4. ✅ Only sound/phoneme processing cancelled
5. ✅ Easy to restore if needed

## 🔄 RESTORATION

To restore cancelled files:
```bash
# Move files back from quarantine
cp -r {self.quarantine_dir}/* .
# Remove stub files
rm [stub file names]
```

## ✅ OPERATION COMPLETE

All phoneme/sound-related coding has been safely cancelled.
The system is now free of risky sound processing patterns.
"""

        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(report_content)

        print(f"\n📋 Report saved: {report_file}")
        return report_file

    def run(self):
        """Execute the complete cancellation process"""
        print("🔍 Step 1: Scanning for phoneme/sound files...")
        phoneme_files = self.scan_workspace()

        if not phoneme_files:
            print("✅ No phoneme/sound files found. Nothing to cancel.")
            return

        print(f"🎯 Found {len(phoneme_files)} phoneme/sound files to cancel")

        # Show preview
        print("\n📋 Files to be cancelled:")
        for file_info in phoneme_files[:10]:  # Show first 10
            risks = len(file_info['risks'])
            size = file_info['size']
            print(f"  - {file_info['path']} ({size:,} bytes, {risks} risk patterns)")

        if len(phoneme_files) > 10:
            print(f"  ... and {len(phoneme_files) - 10} more files")

        # Confirm operation
        print(f"\n🚫 Proceeding with cancellation...")

        # Execute cancellation
        print("\n🚫 Step 2: Cancelling phoneme/sound files...")
        self.cancel_phoneme_files(phoneme_files)

        # Generate report
        print("\n📋 Step 3: Generating cancellation report...")
        report_file = self.generate_report()

        # Final summary
        print(f"\n🎉 PHONEME/SOUND CANCELLATION COMPLETE!")
        print("=" * 50)
        print(f"✅ Files cancelled: {len(self.cancelled_files)}")
        print(f"✅ Stubs created: {len(self.stub_files_created)}")
        print(f"✅ Report: {report_file}")
        print(f"✅ Quarantine: {self.quarantine_dir}")
        print("\n🛡️ All sound/phoneme processing has been safely cancelled.")


def main():
    """Main entry point"""
    canceller = PhonemeCodeCanceller()
    canceller.run()


if __name__ == "__main__":
    main()
