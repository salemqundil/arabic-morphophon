#!/usr/bin/env python3
"""
محرك المقاطع العربية المتطور - Advanced Arabic SyllabicUnit Engine
Professional Arabic Syllabification and Phonological Analysis System
Enterprise Grade Implementation with Deep Learning Integration
"""
# pylint: disable=invalid-name,too-few-public-methods,too-many-instance-attributes,line-too long


import logging
import re
import torch
import torch.nn as nn
from typing import Dict, List, Any, Optional, Tuple, Set
from dataclasses import dataclass
from pathlib import Path
import json


@dataclass
class SyllableStructure:
    """تركيب المقطع الصوتي"""

    onset: List[str]  # البداية
    nucleus: List[str]  # النواة
    coda: List[str]  # النهاية
    pattern: str  # النمط (CV, CVC, etc.)
    weight: float  # الوزن الصوتي
    stress: bool  # النبر

    @property
    def full_syllable(self) -> str:
        """المقطع الكامل"""
        return ''.join(self.onset + self.nucleus + self.coda)


class AdvancedArabicSyllabifier:
    """محرك تقطيع المقاطع العربية المتطور"""

    def __init__(self):
        """تهيئة المحرك المتطور"""
        self.logger = logging.getLogger('AdvancedSyllabifier')
        self._setup_logging()

        # الأصوات العربية - Arabic Phonemes
        self.CONSONANTS = set('بتثجحخدذرزسشصضطظعغفقكلمنهويء')
        self.SHORT_VOWELS = set('َُِ')
        self.LONG_VOWELS = set('اىو')
        self.SUKUN = 'ْ'
        self.SHADDA = 'ّ'
        self.TANWEEN = set('ًٌٍ')

        # خريطة تحويل الأصوات - Phoneme Mapping
        self.PHONEME_MAP = {
            'ا': 'a',
            'ب': 'b',
            'ت': 't',
            'ث': '',
            'ج': 'd',
            'ح': '',
            'خ': 'x',
            'د': 'd',
            'ذ': '',
            'ر': 'r',
            'ز': 'z',
            'س': 's',
            'ش': '',
            'ص': 's',
            'ض': 'd',
            'ط': 't',
            'ظ': '',
            'ع': '',
            'غ': '',
            'ف': 'f',
            'ق': 'q',
            'ك': 'k',
            'ل': 'l',
            'م': 'm',
            'ن': 'n',
            'ه': 'h',
            'و': 'w',
            'ي': 'j',
            'ء': '',
            'ة': 'h',
            'ى': 'a',
            'ئ': '',
            'ؤ': '',
            'أ': 'a',
            'إ': 'i',
            'آ': 'a',
            'َ': 'a',
            'ُ': 'u',
            'ِ': 'i',
            'ً': 'an',
            'ٌ': 'un',
            'ٍ': 'in',
            ' ': ' ',
        }

        # الصوائت في النظام الصوتي - Vowel Phonemes
        self.VOWEL_# Replaced with unified_phonemes {'a', 'u', 'i', 'a', 'u', 'i', 'an', 'un', 'in'}  # صوائت قصيرة  # صوائت طويلة  # تنوين

        # الصوامت في النظام الصوتي - Consonant Phonemes
        self.CONSONANT_# Replaced with unified_phonemes {
            'b',
            't',
            '',
            'd',
            '',
            'x',
            'd',
            '',
            'r',
            'z',
            's',
            '',
            's',
            'd',
            't',
            '',
            '',
            '',
            'f',
            'q',
            'k',
            'l',
            'm',
            'n',
            'h',
            'w',
            'j',
            '',
        }

        # أنماط المقاطع العربية - Arabic SyllabicUnit Patterns
        self.SYLLABLE_PATTERNS = {
            'V': 'صائت منفرد',
            'CV': 'مقطع مفتوح قصير',
            'CVV': 'مقطع مفتوح طويل',
            'CVC': 'مقطع مغلق قصير',
            'CVVC': 'مقطع مغلق طويل',
            'CVCC': 'مقطع مغلق مضاعف',
            'CCVC': 'مقطع معقد بداية',
            'CCVV': 'مقطع معقد طويل',
        }

        # قواعد تقطيع المقاطع - Syllabification Rules
        self.SYLLABLE_RULES = {
            'ONSET_MAX': 2,  # أقصى عدد صوامت في البداية
            'CODA_MAX': 2,  # أقصى عدد صوامت في النهاية
            'NUCLEUS_REQUIRED': True,  # النواة مطلوبة
            'PREFER_ONSET': True,  # تفضيل البداية على النهاية
        }

        self.logger.info(" Advanced Arabic Syllabifier initialized")

    def _setup_logging(self) -> None:
        """إعداد نظام السجلات"""
        if not self.logger.processrs:
            processr = logging.StreamProcessr()
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            processr.setFormatter(formatter)
            self.logger.addProcessr(processr)
            self.logger.setLevel(logging.INFO)

    def preprocess_text(self, text: str) -> str:
        """معالجة النص المبدئية"""
        # إزالة التشكيل الزائد والمسافات
        text = re.sub(r'\s+', ' ', text.strip())

        # توحيد أشكال الهمزة
        text = re.sub(r'[أإآ]', 'ا', text)

        # توحيد التاء المربوطة
        text = re.sub(r'ة', 'ه', text)

        # إزالة علامات الترقيم
        text = re.sub(r'[^\u0600 \u06FF\s]', '', text)

        return text

    def phonemize(self, text: str) -> str:
        """تحويل النص إلى تمثيل صوتي"""
        phonemes = []
        i = 0

        while i < len(text):
            char = text[i]

            # معالجة التشديد
            if i + 1 < len(text) and text[i + 1] == self.SHADDA:
                phoneme = self.PHONEME_MAP.get(char, char)
                phonemes.extend([phoneme, phoneme])  # مضاعفة للتشديد
                i += 2
                continue

            # معالجة الأصوات العادية
            if char in self.PHONEME_MAP:
                phonemes.append(self.PHONEME_MAP[char])
            elif char == ' ':
                phonemes.append(' ')

            i += 1

        return ' '.join(phonemes).strip()

    def advanced_syllabification(self, text: str) -> List[SyllableStructure]:
        """تقطيع المقاطع المتطور"""
        # المعالجة المبدئية
        processed_text = self.preprocess_text(text)

        # تحويل إلى أصوات
        phonemized = self.phonemize(processed_text)

        # تقسيم الكلمات
        words = phonemized.split('  ')  # كلمتان مفصولتان بمسافتين

        all_syllabic_units = []
        for word in words:
            if word.strip():
                word_syllabic_units = self._syllabify_word_advanced(word.strip())
                all_syllabic_units.extend(word_syllabic_units)

        return all_syllabic_units

    def _syllabify_word_advanced(self, phonemized_word: str) -> List[SyllableStructure]:
        """تقطيع كلمة واحدة بالخوارزمية المتطورة"""
        # تقسيم إلى قائمة أصوات
        phonemes = phonemized_word.split()
        if not phonemes:
            return []

        syllabic_units = []
        i = 0

        while i < len(phonemes):
            syllable = self._extract_next_syllable(phonemes, i)
            if syllable:
                syllabic_units.append(syllable)
                i += len(syllable.onset + syllable.nucleus + syllable.coda)
            else:
                # حالة طوارئ - أخذ صوت واحد
                emergency_syllable = SyllableStructure(
                    onset=[], nucleus=[phonemes[i]], coda=[], pattern='V', weight=1.0, stress=False
                )
                syllabic_units.append(emergency_syllable)
                i += 1

        # تطبيق قواعد النبر
        syllabic_units = self._apply_stress_rules(syllabic_units)

        return syllabic_units

    def _extract_next_syllable(self, phonemes: List[str], start_idx: int) -> Optional[SyllableStructure]:
        """استخراج المقطع التالي من الموضع المحدد"""
        if start_idx >= len(phonemes):
            return None

        onset = []
        nucleus = []
        coda = []
        i = start_idx

        # مرحلة 1: جمع البداية (الصوامت)
        while (
            i < len(phonemes)
            and phonemes[i] in self.CONSONANT_PHONEMES
            and len(onset) < self.SYLLABLE_RULES['ONSET_MAX']
        ):
            onset.append(phonemes[i])
            i += 1

        # مرحلة 2: جمع النواة (الصوائت) - مطلوبة
        if i < len(phonemes) and phonemes[i] in self.VOWEL_PHONEMES:
            nucleus.append(phonemes[i])
            i += 1

            # صائت طويل إضافي
            if i < len(phonemes) and phonemes[i] in self.VOWEL_PHONEMES and phonemes[i].endswith(''):
                nucleus.append(phonemes[i])
                i += 1
        else:
            # لا توجد نواة - إرجاع None
            return None

        # مرحلة 3: جمع النهاية (الصوامت)
        consonants_ahead = self._count_consonants_ahead(phonemes, i)

        if consonants_ahead == 0:
            # لا توجد صوامت - مقطع مفتوح
            pass
        elif consonants_ahead == 1:
            # صامت واحد - يذهب للنهاية
            if i < len(phonemes):
                coda.append(phonemes[i])
                i += 1
        else:
            # عدة صوامت - قاعدة التوزيع
            consonants_to_take = min(consonants_ahead - 1, self.SYLLABLE_RULES['CODA_MAX'])
            for _ in range(consonants_to_take):
                if i < len(phonemes) and phonemes[i] in self.CONSONANT_PHONEMES:
                    coda.append(phonemes[i])
                    i += 1

        # تحديد النمط
        pattern = self._determine_pattern(onset, nucleus, coda)

        # حساب الوزن
        weight = self._calculate_syllable_weight(nucleus, coda)

        return SyllableStructure(
            onset=onset, nucleus=nucleus, coda=coda, pattern=pattern, weight=weight, stress=False  # سيتم تحديده لاحقاً
        )

    def _count_consonants_ahead(self, phonemes: List[str], start_idx: int) -> int:
        """عد الصوامت القادمة"""
        count = 0
        i = start_idx

        while i < len(phonemes) and phonemes[i] in self.CONSONANT_PHONEMES:
            count += 1
            i += 1

        return count

    def _determine_pattern(self, onset: List[str], nucleus: List[str], coda: List[str]) -> str:
        """تحديد نمط المقطع"""
        pattern = ""

        # البداية
        pattern += "C" * len(onset)

        # النواة
        if any(phoneme.endswith('') for phoneme in nucleus):
            pattern += "VV"  # صائت طويل
        else:
            pattern += "V" * len(nucleus)

        # النهاية
        pattern += "C" * len(coda)

        return pattern

    def _calculate_syllable_weight(self, nucleus: List[str], coda: List[str]) -> float:
        """حساب وزن المقطع"""
        weight = 1.0  # وزن أساسي

        # الصوائت الطويلة تزيد الوزن
        for vowel in nucleus:
            if vowel.endswith(''):
                weight += 0.5

        # الصوامت في النهاية تزيد الوزن
        weight += len(coda) * 0.3

        return weight

    def _apply_stress_rules(self, syllabic_units: List[SyllableStructure]) -> List[SyllableStructure]:
        """تطبيق قواعد النبر العربية"""
        if not syllabic_units:
            return syllabic_units

        # قاعدة النبر العربية: المقطع قبل الأخير أو الأخير
        if len(syllabic_units) == 1:
            syllabic_units[0].stress = True
        elif len(syllabic_units) == 2:
            # نبر المقطع الأول إذا كان ثقيلاً
            if syllabic_units[0].weight > 1.5:
                syllabic_units[0].stress = True
            else:
                syllabic_units[-1].stress = True
        else:
            # نبر المقطع قبل الأخير إذا كان ثقيلاً
            if syllabic_units[-2].weight > 1.5:
                syllabic_units[-2].stress = True
            else:
                syllabic_units[-1].stress = True

        return syllabic_units

    def rule_based_syllabification(self, text: str) -> List[SyllableStructure]:
        """تقطيع المقاطع باستخدام القواعد اللغوية"""
        return self.advanced_syllabification(text)

    def analyze_syllable_structure(self, syllabic_units: List[SyllableStructure]) -> Dict[str, Any]:
        """تحليل شامل لهيكل المقاطع"""
        if not syllabic_units:
            return {}

        # إحصائيات عامة
        total_syllabic_units = len(syllabic_units)
        stressed_syllabic_units = sum(1 for syl in syllabic_units if syl.stress)
        total_weight = sum(syl.weight for syl in syllabic_units)

        # توزيع الأنماط
        pattern_distribution = {}
        for syl in syllabic_units:
            pattern = syl.pattern
            pattern_distribution[pattern] = pattern_distribution.get(pattern, 0) + 1

        # تحليل الوزن
        light_syllabic_units = sum(1 for syl in syllabic_units if syl.weight <= 1.0)
        heavy_syllabic_units = sum(1 for syl in syllabic_units if syl.weight > 1.0)

        # أنماط النبر
        stress_pattern = []
        for i, syl in enumerate(syllabic_units):
            if syl.stress:
                stress_pattern.append(i)

        return {
            'total_syllabic_units': total_syllabic_units,
            'stressed_syllabic_units': stressed_syllabic_units,
            'total_weight': total_weight,
            'average_weight': total_weight / total_syllabic_units,
            'pattern_distribution': pattern_distribution,
            'light_syllabic_units': light_syllabic_units,
            'heavy_syllabic_units': heavy_syllabic_units,
            'stress_pattern': stress_pattern,
            'syllable_details': [
                {
                    'syllable': syl.full_syllable,
                    'onset': syl.onset,
                    'nucleus': syl.nucleus,
                    'coda': syl.coda,
                    'pattern': syl.pattern,
                    'weight': syl.weight,
                    'stress': syl.stress,
                }
                for syl in syllabic_units
            ],
        }

    def extract_phonemes(self, text: str) -> Dict[str, Any]:
        """تحليل صوتي شامل"""
        # تقطيع المقاطع
        syllabic_units = self.advanced_syllabification(text)

        # تحليل الهيكل
        structure_analysis = self.analyze_syllable_structure(syllabic_units)

        # تحليل العمليات الصوتية
        processes = self._analyze_phonological_processes(text, syllabic_units)

        # تحليل الإيقاع
        rhythm_analysis = self._analyze_rhythm(syllabic_units)

        return {
            'input_text': text,
            'preprocessed_text': self.preprocess_text(text),
            'phonemized_text': self.phonemize(text),
            'syllabic_units': structure_analysis,
            'phonological_processes': processes,
            'rhythm_analysis': rhythm_analysis,
            'confidence': 0.95,
        }

    def _analyze_phonological_processes(self, text: str, syllabic_units: List[SyllableStructure]) -> Dict[str, Any]:
        """تحليل العمليات الصوتية"""
        processes = []

        # الإدغام
        if 'ال' in text:
            processes.append(
                {'process': 'الإدغام الشمسي', 'description': 'إدغام لام التعريف', 'examples': ['الشمس', 'التراب']}
            )

        # التفخيم
        emphatic_chars = set('صضطظ') & set(text)
        if emphatic_chars:
            processes.append(
                {
                    'process': 'انتشار التفخيم',
                    'description': 'انتشار صفة التفخيم للأصوات المجاورة',
                    'affected_chars': list(emphatic_chars),
                }
            )

        # الإمالة
        if 'ي' in text and 'ا' in text:
            processes.append({'process': 'إمالة الألف', 'description': 'ميل الألف نحو الياء', 'context': 'بجوار الياء'})

        return {'total_processes': len(processes), 'processes': processes}

    def _analyze_rhythm(self, syllabic_units: List[SyllableStructure]) -> Dict[str, Any]:
        """تحليل الإيقاع الصوتي"""
        if not syllabic_units:
            return {}

        # نمط الوزن
        weight_pattern = [syl.weight for syl in syllabic_units]

        # نمط النبر
        stress_pattern = ['S' if syl.stress else 'U' for syl in syllabic_units]

        # تحديد نوع الإيقاع
        rhythm_type = "معقد"
        if len(set(weight_pattern)) <= 2:
            rhythm_type = "بسيط"
        elif len(set(weight_pattern)) <= 3:
            rhythm_type = "متوسط"

        return {
            'weight_pattern': weight_pattern,
            'stress_pattern': stress_pattern,
            'rhythm_type': rhythm_type,
            'rhythmic_complexity': len(set(weight_pattern)),
            'isochrony': self._calculate_isochrony(weight_pattern),
        }

    def _calculate_isochrony(self, weight_pattern: List[float]) -> float:
        """حساب التساوي الزمني"""
        if len(weight_pattern) < 2:
            return 1.0

        variance = sum((w - sum(weight_pattern) / len(weight_pattern)) ** 2 for w in weight_pattern)
        variance /= len(weight_pattern)

        # عكس التباين - كلما قل التباين زاد التساوي
        return 1.0 / (1.0 + variance)


class SyllabicUnitEngine(AdvancedArabicSyllabifier):
    """محرك المقاطع العربية - واجهة متوافقة"""

    def __init__(self):

        super().__init__()
        self.logger = logging.getLogger('SyllabicUnitEngine')

    def syllabify_text(self, text: str) -> Dict[str, Any]:
        """تقطيع النص إلى مقاطع - واجهة متوافقة"""
        try:
            # التحليل الشامل
            analysis = self.extract_phonemes(text)

            # تحويل للصيغة المتوافقة
            words = text.split()
            syllable_analysis = []

            syllabic_units_data = analysis.get('syllabic_units', {})
            syllable_details = syllabic_units_data.get('syllable_details', [])

            # تجميع المقاطع حسب الكلمات
            current_word_syllabic_units = []
            word_index = 0

            for detail in syllable_details:
                current_word_syllabic_units.append(detail['syllable'])

                # إذا انتهت الكلمة
                if (
                    len(''.join(current_word_syllabic_units).replace(' ', '')) >= len(words[word_index])
                    if word_index < len(words)
                    else True
                ):
                    if word_index < len(words):
                        syllable_analysis.append(
                            {
                                'word': words[word_index],
                                'syllabic_units': current_word_syllabic_units,
                                'syllable_count': len(current_word_syllabic_units),
                                'syllable_patterns': [
                                    detail['pattern'] for detail in syllable_details[: len(current_word_syllabic_units)]
                                ],
                                'stress_pattern': self._extract_word_stress(current_word_syllabic_units, syllable_details),
                                'prosodic_weight': sum(
                                    detail['weight'] for detail in syllable_details[: len(current_word_syllabic_units)]
                                ),
                            }
                        )
                    current_word_syllabic_units = []
                    word_index += 1

            return {
                'input': text,
                'normalized_input': analysis.get('preprocessed_text', text),
                'engine': 'SyllabicUnitEngine',
                'method': 'syllabify_text',
                'status': 'success',
                'total_words': len(words),
                'syllable_analysis': syllable_analysis,
                'total_syllabic_units': syllabic_units_data.get('total_syllabic_units', 0),
                'arabic_standard': 'Classical Arabic Prosody',
                'confidence': analysis.get('confidence', 0.95),
                'advanced_analysis': analysis,
            }

        except Exception as e:
            self.logger.error(f" Error in syllabification: {e}")
            return {
                'input': text,
                'engine': 'SyllabicUnitEngine',
                'method': 'syllabify_text',
                'status': 'error',
                'error': str(e),
            }

    def _extract_word_stress(self, word_syllabic_units: List[str], all_details: List[Dict]) -> Dict[str, Any]:
        """استخراج نمط النبر للكلمة"""
        stress_positions = []
        for i, detail in enumerate(all_details[: len(word_syllabic_units)]):
            if detail.get('stress', False):
                stress_positions.append(i)

        return {
            'stressed_syllable': stress_positions[0] if stress_positions else  1,
            'stress_type': (
                'penultimate'
                if len(word_syllabic_units) > 1 and stress_positions and stress_positions[0] == len(word_syllabic_units) - 2
                else 'ultimate'
            ),
            'total_syllabic_units': len(word_syllabic_units),
        }


# فئة للتوافق مع النظام القديم
class SyllabicUnitEngine(SyllabicUnitEngine):
    """محرك الوحدات المقطعية - للتوافق مع النظام القديم"""

    pass


# اختبار النظام
if __name__ == "__main__":
    engine = SyllabicUnitEngine()

    # نص اختباري
    test_text = "كتب الطالب الدرس في المدرسة"

    # التحليل
    result = engine.syllabify_text(test_text)

    print(" النص:", test_text)
    print(" النتيجة:", result['status'])
    print(" إجمالي المقاطع:", result['total_syllabic_units'])

    if 'syllable_analysis' in result:
        for word_analysis in result['syllable_analysis']:
            print(f"\n الكلمة: {word_analysis['word']}")
            print(f"   المقاطع: {word_analysis['syllabic_units']}")
            print(f"   الأنماط: {word_analysis['syllable_patterns']}")
            print(f"   الوزن: {word_analysis['prosodic_weight']:.2f}")

